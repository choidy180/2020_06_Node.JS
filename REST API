#REST API

REST는 웹의 창시자(HTTP) 중의 한 사람인 Roy Fielding의 2000년 논문에 의해서 소개되었습니다.
현재의 아키텍처가 웹의 본래 설계의 우수성을 많이 사용하지 못하고 있다고 판단했기 때문에, 웹의
장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개하였고 그것이 바로

Representational state transfer (Rest) 입니다.

REST의 요소로는 크게 리소스, 메서드, 메세지 3가지 요소로 구성됩니다.

예를 들어 “이름이 Kim인 사용자를 생성한다” 라는 호출이 있을 때 
“사용자”는 생성되는 리소스. “생성한다”라는 행위는 메서드 그리고 ‘이름이 Kim인 사용자’는 메시지입니다.

이를 REST형태로 표현할시
HTTP POST, http://myweb/users/
{
    “users”: {
        “name”:”Kim”
    }
}
이라는 형태로 표현 되고 , 생성한다는 의미를 갖는 메서드는 HTTP Post 메서드가 되고 생성하고자 하는 대상이 되는 사용자라는 리소스는 http://myweb/users 라는 형태의 URI로 표현되고 생성하고자 하는 사용자의 디테일한 내용은 JSON 문서를 이용해서 표현합니다.

REST에서는 앞에서 잠깐 언급한 바와 같이, 행위에 대한 메서드를 HTTP 메서드를 그대로 사용합니다.
HTTP 에는 여러가지 메서드가 있지만 REST에서는 CRUD에 해당하는 4가지의 메서드만 사용합니다.

각각 POST, PUT, GET, DELETE는 각각의
CRUD 메서드에 대응 됩니다.

예를 들어 a++ 는 Idempotent 하지않다고 해도 (호출시 마다 값 증가), a=4와 같은 명령은 반복적으로 수행해도 수행시 결과가 같습니다.

POST 연산의 경우 리소스를 추가하는 연산이기 때문에, 여러 번 수행시 결과가 같지 않지만 
나머지 GET, PUT, DELETE는 반복 수행해도 결과가 같습니다. GET의 경우 게시물의 조회수를 늘려준다던가
하는 기능을 같이 수행했을 때는 Idempotent(여러 번 수행기 같은 결과) 하지않은 메서드로 정의 해야 한다

Idempotent 개념이 중요한 이유는 REST는 각 개별 API를 상태 없이 수행하게 되고, 
따라서 해당 REST API를 다른 API와 함께 호출하다가 실패하였을 경우, 트렌젝션 복구를 위해서 
다시 원복해줘야 하는 문제가 있지만, Idempotent한 메서드의 경우에는 반복적으로으로 다시 메서드를 수행해주면 됩니다.

예를 들자면 게시물 조회 API가 있을때, 조회시 마다 조회수를 올리는 연산을 수행한다면 이 메서드는 
Idempotent 하다고 볼 수 없고, 조회하다가 실패하였을 때는 올라간 조회수를 다시 -1로 빼줘야 합니다.
즉 Idempotent 하지 않은 메서드에 대해서는 트랜잭션에 대한 처리에 주의가 필요합니다.

REST는 리소스 지향 아키텍처 스타일이라는 정의답게 모든 것을 리소스(명사)로 표현하며,
각 리소스에는 id를 붙힙니다.
즉 사용자라는 리소스 타입을 http://myweb/users라고 정의를 했다면, 
kim이라는 id를 갖는 리소스는 http://myweb/users/kim  이라는 형태로 정의합니다.

REST라는 리소스가 명사의 형태를 띄우다 보니, 명령(Operation)성의 API를 정의하는 것에서 혼돈이 올 수 있는데 예를 들어 “Push 메세지를 보낸다”는 보통 기존의 RPC(Remote Procedure Call)이나
함수성 접근에서는 /myweb/sendpush 형태로 잘못 정의될 수 있으나, 이러한 동사형을 명사형으로 
바꾸어 적용하면 리소스 형태로 표현하기가 조금 더 수월해 집니다.

*RPC(Remote Procedure Call)
RPC(원격 프로시저 호출)은 별도의 원격 제어를 위한 코딩없이 다른 주소 공간에서 함수나 프로시저를
실행할 수 있게하는 프로세스 간 통신기술입니다.

“Push 메시지 요청을 생성한다.”라는 형태로 정의를 변경하면,
API 포맷은 POST/myweb/push 형태와 같이 명사형으로 정의가 될 수 있습니다.
물론 모든 형태의 명령이 이런 형태로 정의가 가능한 것은 아니나, 
되도록이면 리소스 기반의 명사형태로 정의를 하는게 REST 형태의 디자인이 된다.

간단한 사용자 생성 API를 살펴보면
HTTP Post, http://myweb/users/
{
    “name”:”kim”,
    “address”:”busan”
}
위의 예제는 http://myweb/users 라는 리소스를, 이름은 kim, 주소는 busan 이라는 내용(메시지)로
HTTP Post를 이용해서 생성하는 예제입니다.

[ 조회 ] 
생성된 리소스 중 http://myweb/users 라는 사용자 리소스 중, id가 kim인 사용자 정보를 조회하는 것이다.
조회이기 때문에 HTTP Get을 사용한다.

HTTP Get, http://myweb/users/kim

[ 업데이트 ]
http://myweb/users라는 사용자 리소스 중에, id가 kim인 사용자 정보에 대해서, 
주소를 “seoul”로 수정하는 방식입니다. 수정은 HTTP 메서드 중에 PUT를 사용합니다.
HTTP PUT, http://myweb/users/kim
{
    “name”:”kim”
    “address”:”seoul”
}

[ 삭제 ] 
http://myweb/users 라는 사용자 리소스 중에, id가 kim 사용자 정보를 삭제 하는 방법입니다.
HTTP DELETE, http://myweb/users/kim

API 정의는 상당히 간단하고 단순하게 리소스를 URI로 정해준 후에, 거기에 HTTP 메서드를 이용해서
CRUD를 구현하고 메시지를 JSON으로 표현하여 HTTP Body에 실어 보내면 됩니다.
POST URI에 리소스 id가 없다는 것을 빼면 크게 신경쓸 부분이 없습니다.

유니폼 인터페이스(Uniform Interface)

REST는 HTTP 표준에만 따른다면, 어떠한 기술이라도 사용이 가능한 인터페이스 스타일입니다.
예를 들어 HTTP + JSON으로 REST API를 정의했다면, 안드로이드 플랫폼이건 IOS 플랫폼이건, 또는
C나 JAVA, PYTHON이건 특정 언어나 기술에 종속 받지 않고 HTTP와 JSON을 사용할 수 있는 
모든 플랫폼에 사용이 가능한 느슨한 결함(Loosely coupling) 형태의 구조입니다..

*흔히 근래에 REST를 이야기 하면, HTTP + JSON을 쉽게 떠올리는데, JSON은 하나의 옵션일 뿐,
메시지 포맷을 꼭 JSON으로 적용해야할 필요가 없습니다. 자바스크립트 유행 전에는 XML 형태를 많이
사용하였고, 근래에 들어서 사용의 편리성 때문에 JSON을 사용하나, XML을 사용할 경우,
XPath,XSL등 다양한 XML 프레임워크를 사용할 수 있고, 메시지 구조를 명시적으로 정의 가능한
XML Schema나 DTD등을 사용할 수 있기 때문에, 복잡도는 상승하나 메시지 정의 명확성을 더할 수 있습니다.

무상태성/스테이트리스(Stateless)

REST는 REpresentational State Transfer의 약어로 Stateless (상태를 유지하지 않음)이 특징 중 하나입니다.
상태가 있다 없다는 의미는 사용자나 클라이언트의 컨텍스트를 서버쪽에 유지 하지 않는다는 의미로,
쉽게 표현하면 HTTP Session과 같은 컨텍스트 저장소에 상태 정보를 저장하지 않는 형태를 의미합니다.
상태 정보를 저장하지 않으면 각 API 서버는 들어오는 요청만을 들어오는 메시지로만 처리하면 되고,
세션과 같은 컨텍스트 정보를 신경쓸 필요가 없기 때문에 구현이 단순해집니다.

