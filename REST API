#REST API

REST는 웹의 창시자(HTTP) 중의 한 사람인 Roy Fielding의 2000년 논문에 의해서 소개되었습니다.
현재의 아키텍처가 웹의 본래 설계의 우수성을 많이 사용하지 못하고 있다고 판단했기 때문에, 웹의
장점을 최대한 활용할 수 있는 네트워크 기반의 아키텍처를 소개하였고 그것이 바로

Representational state transfer (Rest) 입니다.

REST의 요소로는 크게 리소스, 메서드, 메세지 3가지 요소로 구성됩니다.

예를 들어 “이름이 Kim인 사용자를 생성한다” 라는 호출이 있을 때 
“사용자”는 생성되는 리소스. “생성한다”라는 행위는 메서드 그리고 ‘이름이 Kim인 사용자’는 메시지입니다.

이를 REST형태로 표현할시
HTTP POST, http://myweb/users/
{
    “users”: {
        “name”:”Kim”
    }
}
이라는 형태로 표현 되고 , 생성한다는 의미를 갖는 메서드는 HTTP Post 메서드가 되고 생성하고자 하는 대상이 되는 사용자라는 리소스는 http://myweb/users 라는 형태의 URI로 표현되고 생성하고자 하는 사용자의 디테일한 내용은 JSON 문서를 이용해서 표현합니다.

REST에서는 앞에서 잠깐 언급한 바와 같이, 행위에 대한 메서드를 HTTP 메서드를 그대로 사용합니다.
HTTP 에는 여러가지 메서드가 있지만 REST에서는 CRUD에 해당하는 4가지의 메서드만 사용합니다.

각각 POST, PUT, GET, DELETE는 각각의
CRUD 메서드에 대응 됩니다.

예를 들어 a++ 는 Idempotent 하지않다고 해도 (호출시 마다 값 증가), a=4와 같은 명령은 반복적으로 수행해도 수행시 결과가 같습니다.

POST 연산의 경우 리소스를 추가하는 연산이기 때문에, 여러 번 수행시 결과가 같지 않지만 
나머지 GET, PUT, DELETE는 반복 수행해도 결과가 같습니다. GET의 경우 게시물의 조회수를 늘려준다던가
하는 기능을 같이 수행했을 때는 Idempotent(여러 번 수행기 같은 결과) 하지않은 메서드로 정의 해야 한다

Idempotent 개념이 중요한 이유는 REST는 각 개별 API를 상태 없이 수행하게 되고, 
따라서 해당 REST API를 다른 API와 함께 호출하다가 실패하였을 경우, 트렌젝션 복구를 위해서 
다시 원복해줘야 하는 문제가 있지만, Idempotent한 메서드의 경우에는 반복적으로으로 다시 메서드를 수행해주면 됩니다.

예를 들자면 게시물 조회 API가 있을때, 조회시 마다 조회수를 올리는 연산을 수행한다면 이 메서드는 
Idempotent 하다고 볼 수 없고, 조회하다가 실패하였을 때는 올라간 조회수를 다시 -1로 빼줘야 합니다.
즉 Idempotent 하지 않은 메서드에 대해서는 트랜잭션에 대한 처리에 주의가 필요합니다.

REST는 리소스 지향 아키텍처 스타일이라는 정의답게 모든 것을 리소스(명사)로 표현하며,
각 리소스에는 id를 붙힙니다.
즉 사용자라는 리소스 타입을 http://myweb/users라고 정의를 했다면, 
kim이라는 id를 갖는 리소스는 http://myweb/users/kim  이라는 형태로 정의합니다.

REST라는 리소스가 명사의 형태를 띄우다 보니, 명령(Operation)성의 API를 정의하는 것에서 혼돈이 올 수 있는데 예를 들어 “Push 메세지를 보낸다”는 보통 기존의 RPC(Remote Procedure Call)이나
함수성 접근에서는 /myweb/sendpush 형태로 잘못 정의될 수 있으나, 이러한 동사형을 명사형으로 
바꾸어 적용하면 리소스 형태로 표현하기가 조금 더 수월해 집니다.

*RPC(Remote Procedure Call)
RPC(원격 프로시저 호출)은 별도의 원격 제어를 위한 코딩없이 다른 주소 공간에서 함수나 프로시저를
실행할 수 있게하는 프로세스 간 통신기술입니다.

“Push 메시지 요청을 생성한다.”라는 형태로 정의를 변경하면,
API 포맷은 POST/myweb/push 형태와 같이 명사형으로 정의가 될 수 있습니다.
물론 모든 형태의 명령이 이런 형태로 정의가 가능한 것은 아니나, 
되도록이면 리소스 기반의 명사형태로 정의를 하는게 REST 형태의 디자인이 된다.

간단한 사용자 생성 API를 살펴보면
HTTP Post, http://myweb/users/
{
    “name”:”kim”,
    “address”:”busan”
}
위의 예제는 http://myweb/users 라는 리소스를, 이름은 kim, 주소는 busan 이라는 내용(메시지)로
HTTP Post를 이용해서 생성하는 예제입니다.

[ 조회 ] 
생성된 리소스 중 http://myweb/users 라는 사용자 리소스 중, id가 kim인 사용자 정보를 조회하는 것이다.
조회이기 때문에 HTTP Get을 사용한다.

HTTP Get, http://myweb/users/kim

[ 업데이트 ]
http://myweb/users라는 사용자 리소스 중에, id가 kim인 사용자 정보에 대해서, 
주소를 “seoul”로 수정하는 방식입니다. 수정은 HTTP 메서드 중에 PUT를 사용합니다.
HTTP PUT, http://myweb/users/kim
{
    “name”:”kim”
    “address”:”seoul”
}

[ 삭제 ] 
http://myweb/users 라는 사용자 리소스 중에, id가 kim 사용자 정보를 삭제 하는 방법입니다.
HTTP DELETE, http://myweb/users/kim

API 정의는 상당히 간단하고 단순하게 리소스를 URI로 정해준 후에, 거기에 HTTP 메서드를 이용해서
CRUD를 구현하고 메시지를 JSON으로 표현하여 HTTP Body에 실어 보내면 됩니다.
POST URI에 리소스 id가 없다는 것을 빼면 크게 신경쓸 부분이 없습니다.

유니폼 인터페이스(Uniform Interface)

REST는 HTTP 표준에만 따른다면, 어떠한 기술이라도 사용이 가능한 인터페이스 스타일입니다.
예를 들어 HTTP + JSON으로 REST API를 정의했다면, 안드로이드 플랫폼이건 IOS 플랫폼이건, 또는
C나 JAVA, PYTHON이건 특정 언어나 기술에 종속 받지 않고 HTTP와 JSON을 사용할 수 있는 
모든 플랫폼에 사용이 가능한 느슨한 결함(Loosely coupling) 형태의 구조입니다..

*흔히 근래에 REST를 이야기 하면, HTTP + JSON을 쉽게 떠올리는데, JSON은 하나의 옵션일 뿐,
메시지 포맷을 꼭 JSON으로 적용해야할 필요가 없습니다. 자바스크립트 유행 전에는 XML 형태를 많이
사용하였고, 근래에 들어서 사용의 편리성 때문에 JSON을 사용하나, XML을 사용할 경우,
XPath,XSL등 다양한 XML 프레임워크를 사용할 수 있고, 메시지 구조를 명시적으로 정의 가능한
XML Schema나 DTD등을 사용할 수 있기 때문에, 복잡도는 상승하나 메시지 정의 명확성을 더할 수 있습니다.

무상태성/스테이트리스(Stateless)

REST는 REpresentational State Transfer의 약어로 Stateless (상태를 유지하지 않음)이 특징 중 하나입니다.
상태가 있다 없다는 의미는 사용자나 클라이언트의 컨텍스트를 서버쪽에 유지 하지 않는다는 의미로,
쉽게 표현하면 HTTP Session과 같은 컨텍스트 저장소에 상태 정보를 저장하지 않는 형태를 의미합니다.
상태 정보를 저장하지 않으면 각 API 서버는 들어오는 요청만을 들어오는 메시지로만 처리하면 되고,
세션과 같은 컨텍스트 정보를 신경쓸 필요가 없기 때문에 구현이 단순해집니다.

캐싱

컴퓨터에서 캐시는 일반적으로 일시적인 특징이 있는 데이터 하위 집합을 저장하는 고속 데이터 스토리지
계층입니다. 따라서 이후에 해당 데이터에 대한 요청이 있을 경우 데이터의 기본 스토리지 위치에 
엑세스 할 때 보다 더 빠르게 요청을 처리할 수 있고, 캐싱을 사용하면 이전에 검색하거나 계산한 데이터를
효율적으로 재사용할 수 있습니다.

캐시의 데이터는 일반적으로  RAM과 같이 빠르게 액세스할 수 있는 하드웨어에 저장되며,
소프트웨어 구성 요소와 함께 사용될 수도 있습니다. 캐시의 주요 목적은 더 느린 기본 스토리지 계층에
엑세스 해야 하는 필요를 줄여서 데이터 검색 기능을 향상하는 것 입니다.

속도를 위해 용량을 정충하는 캐시는 일반적으로 데이터의 하위 집합을 일시적으로 저장합니다.
보통 완전하고 영구적인 데이터가 있는 데이터베이스와는 대조적입니다.

캐싱 가능(Cacheable)

REST의 큰 특징 중의 하나는 HTTP라는 기존의 웹 표준을 그대로 사용하기 때문에,
웹에서 사용하는 기존의 인프라를 그대로 활용이 가능합니다.
HTTP 프로토콜 기반의 로드 밸런서나 SSL은 물론이고, HTTP가 가진 가장 강력한 특징중의 하나인
캐싱 기능을 적용할 수 있습니다. 일반적인 서비스 시스템에서 60%에서 많게는 80%가량의 트랜잭션이
Select와 같은 조회성 트랜잭션인 것을 감안할 시, HTTP의 리소스들을 웹캐시 서버등에 캐슁하는 것은
용량이나 성능 면에서 많은 장점을 가지고 올 수 있습니다. 

구현은 HTTP 프로토콜 표준에서 사용하면 “Last-Modified” 태그나 E-Tag를 이용해 캐싱을 구현 가능합니다
다음 이미지와 같이 Client가 HTTP GET을 “Last-Modified” 값과 함께 보냈을 때, 컨텐츠가 변화가 없으면
REST 컴포넌트는 “304 Not Modified”를 리턴하면 Client는 자체 캐시에 저장된 값을 사용하게 됩니다.

REST의 가장 큰 특징 중의 하나는 REST API 자체가 매우 쉬워서 API 메시지 자체만 보고도 API를 이해할 수 있는 Self-descriptiveness 구조를 갖는 다는 것입니다. 리소스와 메서드를 이용해서 어떤 메서드에 무슨
행위를 하는지를 알 수 있으며, 또한 메시지 포맷 역시 JSON을 이용해서 직관적으로 이해가 가능한
구조입니다.

대부분의 REST 기반의 OPEN API들이 API 문서를 별도로 제공하고 있으나, 디자인 사상은 최소한의
문서의 도움만으로도 API 자체를 이해할 수 있어야 합니다.

클라이언트 서버 구조 (Client-Server 구조)

근래에 들면서 재정립되고 있는 특징 중의 하나는 REST가 클라이언트 서버 구조라는 것입니다.
REST 서버는 API를 제공하고, 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임집니다.

클라이언트의 경우 사용자 인증이나 컨텍스트 (세션, 로그인 정보)등을 직접 관리하고 책임 지는 구조로
역할이 나뉘어 지고 있습니다. 이렇게 역할이 각각 확실하게 구분되면서, 개발 관점에서 클라이언트와
서버에서 개발해야 할 내용들이 명확하게 되고 서로의 개발에 있어서 의존성이 줄어들게 됩니다.

계층적 구조 (Layered System)

계층적 아키텍처 구조 역시 근래에 들어서 주목받기 시작하는 구조인데, 클라이언트 입장에서는
REST API 서버만 호출합니다.

그러나 서버는 다중 계층으로 구성 될 수 있습니다. 순수 비즈니스 로직을 수행하는 API 서버와 그 앞단에
사용자 인증(Authentication), 암호화(SSL), 로드밸런싱등을 하는 계층을 추가해서 구조상의 유연성을 
둘 수 있는데, 이는 근래에 들어서 앞에서 언급한 마이크로 서비스 아키텍처의 API GATEWAY나,
간단한 기능의 경우에는 HA Proxy나 Apache와 같은 Reverse Proxy를 이용해서 구현하는 경우가
많습니다

GET / POST를 이용한 터널링

가장 나쁜 디자인 중 하나가 GET이나 POST를 이용한 터널링입니다.
http://myweb/users?method=update&id=kim 이 경우가 전형적인 GET을 이용한 터널링입니다.
메서드의 실제 동작은 리소스를 업데이트하는 내용인데, HTTP PUT을 사용하지 않고, 
GET에 쿼리 패러미터로 method=update라고 넘겨서, 이 메서드가 수정 메서드임을 명시했습니다.

매우 안좋은 디자인인데, HTTP 메서드 사상을 따르지 않았기 때문에, REST라고 부를 수 도 없고,
또한 웹 캐시 인프라 등도 사용이 불가능합니다.


GET / POST를 이용한 터널링

POST를 이용한 터널링은 Insert(Create)성 오퍼레이션이 아닌데도 불구하고, JSON 바디에
오퍼레이션 명을 넘기는 형태인데 예를 들어 특정 사용자 정보를 가지고 오는 API를 아래와 같이
POST를 이용해서 만든 경우입니다.

HTTP POST, http://myweb/users/
{
    “getuser”: {
        “id”:”kim”,
    }
}

Self-descriptiveness 속성을 사용하지 않음

앞서 특징에서 설명한 바와 같이 REST의 특성 중 하나는 자기 서술성(Self-descriptiveness) 속성으로
REST URI와 메서드, 그리고 쉽게 정의된 메시지 포맷에 의해서 쉽게 API를 이해할 수 있는 기능이
되어야 합니다. 특히나 자기 서술성을 깨먹는 가장 대표적인 사례가 앞서 언급한 
GET이나 POST를 이용한 터널링을 이용한 구조가 됩니다.

HTTP Response code를 사용하지 않음

많이 하는 실수중의 하나가 Http Response code를 충실하게 따르지 않고, 성공은 200, 실패는 500과 같이
1~2개의 HTTP response code만 사용하는 경우입니다. 
심한 경우에는 에러도 HTTP Response code으로 정의한 후 별도의 에러 메시지를 
200 response code와 함께 보내는 경우인데, 이는 REST 디자인 사상에도 어긋남은 물론이고 
자기 서술성에도 어긋납니다. 

REST의 특성을 이해하고 나쁜 안티패턴을 회피해서 REST API 디자인 하기 위한 방법으로는 
REST API를 URI만 보고도, 직관적으로 이해할 수 있어야 한다 URL을 길게 만드는 것보다, 
최대 2 depth 정도로 간단하게 만드는 것이 이해하기 편합니다.

ex) /dogs , /dogs/1234

URI에 리소스명은 동사보다는 명사를 사용합니다.
REST API는 리소스에 대해서 행동을 정의하는 형태를 사용합니다. 예를 들자면

ex) POST /dogs
는 /dogs라는 리소스를 생성하라는 의미로, URL은 HTTP Method에 의해 CRUD의 대상이 되는 
개체(명사)여야 합니다.

잘못된 예로는
HTTP Post : /getDogs
HTTP Post : /setDogsOwner

위의 예제는 행위를 HTTP Post로 정의하지 않고, get/set 등의 행위를 URL에 붙인 경우인데,
좋지 않은 예입니다. 이보다는

HTTP Get : /dogs
HTTP Post : /dogs/{puppy}/owner/{kim}

이런식으로 사용하는 것이 좋고, 가급적이면 단수형 명사보다 dogs같이 복수형 명사를 쓰는것이
의미상 표현이 좋습니다.

잘못된 예로는
HTTP Post : /getDogs
HTTP Post : /setDogsOwner

위의 예제는 행위를 HTTP Post로 정의하지 않고, get/set 등의 행위를 URL에 붙인 경우인데,
좋지 않은 예입니다. 이보다는

HTTP Get : /dogs
HTTP Post : /dogs/{puppy}/owner/{kim}

이런식으로 사용하는 것이 좋고, 가급적이면 단수형 명사보다 dogs같이 복수형 명사를 쓰는것이
의미상 표현이 좋습니다.


